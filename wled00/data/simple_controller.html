<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WLED è°ƒè‰²ç›˜</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: white;
            font-family: sans-serif;
            text-align: center;
            margin: 30px 0;
        }
        canvas {
            border-radius: 50%;
            display: block;
            margin: 10px auto;
            cursor: crosshair;
        }
    </style>
</head>
<body>

<h2>ğŸ¨ WLED è°ƒè‰²ç›˜</h2>
<canvas id="colorWheel" width="300" height="300"></canvas>
<p>RGB: <span id="rgbText">-</span></p>
<div>
    <p>å½“å‰æ•ˆæœ: <span id="effectName">-</span></p>
    <select id="effectSelect"></select>
    <button id="setEffectBtn">è®¾ç½®æ•ˆæœ</button>
</div>


<script>
    const canvas = document.getElementById("colorWheel");
    const ctx = canvas.getContext("2d");
    const rgbText = document.getElementById("rgbText");
    const radius = canvas.width / 2;
    let lastClick = null;

    const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
    const ip = isLocal ? "http://4.3.2.1" : "";  // æˆ– null/undefinedï¼Œå¦‚æœä½ æƒ³ä¸è°ƒç”¨


    function drawColorWheel() {
        const image = ctx.createImageData(canvas.width, canvas.height);
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const dx = x - radius;
                const dy = y - radius;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= radius) {
                    const angle = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
                    const sat = dist / radius;
                    const { r, g, b } = hslToRgb(angle, sat, 0.5);
                    const index = (y * canvas.width + x) * 4;
                    image.data[index] = r;
                    image.data[index + 1] = g;
                    image.data[index + 2] = b;
                    image.data[index + 3] = 255;
                }
            }
        }
        ctx.putImageData(image, 0, 0);
    }

    function hslToRgb(h, s, l) {
        h /= 360;
        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }

    function getColorAt(x, y) {
        const imgData = ctx.getImageData(x, y, 1, 1).data;
        return { r: imgData[0], g: imgData[1], b: imgData[2] };
    }

    function sendToWLED(r, g, b) {
        fetch(`${ip}/json/state`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ seg: [{ col: [[r, g, b]] }] })
        }).catch(err => console.warn("å‘é€å¤±è´¥:", err));
    }

    function drawSelectionCircle(x, y) {
        if (!x || !y) return;
        drawColorWheel(); // å…ˆæ¸…é™¤æ—§åœˆ
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    function findColorPosition(targetR, targetG, targetB) {
        const tolerance = 15; // é¢œè‰²è¯¯å·®å®¹å¿èŒƒå›´
        for (let y = 0; y < canvas.height; y += 2) {
            for (let x = 0; x < canvas.width; x += 2) {
                const { r, g, b } = getColorAt(x, y);
                const dr = Math.abs(r - targetR);
                const dg = Math.abs(g - targetG);
                const db = Math.abs(b - targetB);
                const dx = x - radius;
                const dy = y - radius;
                if (dr < tolerance && dg < tolerance && db < tolerance && dx * dx + dy * dy <= radius * radius) {
                    return { x, y };
                }
            }
        }
        return null;
    }

    async function fetchColor() {
        try {
            const res = await fetch(`${ip}/json/state`);
            const data = await res.json();
            const [r, g, b] = data.seg?.[0]?.col?.[0] || [255, 0, 0];
            rgbText.textContent = `${r}, ${g}, ${b}`;

            // æŸ¥æ‰¾è¯¥ RGB æ‰€åœ¨åœ†ç›˜ä½ç½®
            const match = findColorPosition(r, g, b);
            if (match) {
                drawSelectionCircle(match.x, match.y);
            }
            fetchCurrentEffect(data)
        } catch (err) {
            console.warn("âŒ æ— æ³•æ‹‰å– WLED å½“å‰é¢œè‰²:", err);
        }
    }

    canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - radius;
        const dy = y - radius;
        if (dx * dx + dy * dy > radius * radius) return;

        lastClick = { x, y };
        const { r, g, b } = getColorAt(x, y);
        rgbText.textContent = `${r}, ${g}, ${b}`;
        drawSelectionCircle(x, y);
        sendToWLED(r, g, b);
    });

    drawColorWheel();


    const effectNameEl = document.getElementById("effectName");
    const effectSelect = document.getElementById("effectSelect");
    const setEffectBtn = document.getElementById("setEffectBtn");

    // WLEDçš„æ•ˆæœåˆ—è¡¨ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…å¯ä»å®˜æ–¹æ–‡æ¡£æˆ–æ¥å£è·å–ï¼‰
    const effects = [
        { id: 0, name: "Solid" },
        { id: 1, name: "Blink" },
        { id: 2, name: "Breath" },
        { id: 3, name: "Wipe" },
        { id: 4, name: "Rainbow" },
        // ... å¯æ ¹æ®éœ€è¦è¡¥å……æ›´å¤šæ•ˆæœ
    ];

    function populateEffects() {
        effects.forEach(e => {
            const opt = document.createElement("option");
            opt.value = e.id;
            opt.textContent = e.name;
            effectSelect.appendChild(opt);
        });
    }

    async function fetchCurrentEffect(data) {
        try {
            const fxId = data.seg?.[0]?.fx;
            const fxName = data.seg?.[0]?.fxname || "-";

            effectNameEl.textContent = fxName;

            // é€‰ä¸­å½“å‰æ•ˆæœ
            if (fxId !== undefined) {
                effectSelect.value = fxId;
            }
        } catch (err) {
            console.warn("æ‹‰å–æ•ˆæœå¤±è´¥", err);
            effectNameEl.textContent = "è·å–å¤±è´¥";
        }
    }

    async function setEffect() {
        try {
            const fx = parseInt(effectSelect.value);
            await fetch(`${ip}/json/state`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ seg: [{ fx }] })
            });
        } catch (err) {
            alert("è®¾ç½®æ•ˆæœå¤±è´¥ï¼š" + err);
        }
    }

    setEffectBtn.addEventListener("click", setEffect);

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    window.addEventListener("DOMContentLoaded", () => {
        populateEffects();
        fetchColor();
    });

</script>
</body>
</html>
